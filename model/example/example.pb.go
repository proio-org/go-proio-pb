// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proio/model/example/example.proto

package example

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Particle struct {
	// ProIO entry identifiers that point to parent Particles
	Parent []uint64 `protobuf:"varint,1,rep,packed,name=parent,proto3" json:"parent,omitempty"`
	// ProIO entry identifiers that point to child Particles
	Child []uint64 `protobuf:"varint,2,rep,packed,name=child,proto3" json:"child,omitempty"`
	// PDG code
	Pdg int32 `protobuf:"zigzag32,3,opt,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in mm
	Vertex *XYZTF `protobuf:"bytes,4,opt,name=vertex,proto3" json:"vertex,omitempty"`
	// momentum in GeV
	P *XYZF `protobuf:"bytes,5,opt,name=p,proto3" json:"p,omitempty"`
	// mass in GeV
	Mass float32 `protobuf:"fixed32,6,opt,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               int32    `protobuf:"zigzag32,7,opt,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Particle) Reset()         { *m = Particle{} }
func (m *Particle) String() string { return proto.CompactTextString(m) }
func (*Particle) ProtoMessage()    {}
func (*Particle) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{0}
}
func (m *Particle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Particle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Particle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Particle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Particle.Merge(m, src)
}
func (m *Particle) XXX_Size() int {
	return m.Size()
}
func (m *Particle) XXX_DiscardUnknown() {
	xxx_messageInfo_Particle.DiscardUnknown(m)
}

var xxx_messageInfo_Particle proto.InternalMessageInfo

func (m *Particle) GetParent() []uint64 {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Particle) GetChild() []uint64 {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *Particle) GetPdg() int32 {
	if m != nil {
		return m.Pdg
	}
	return 0
}

func (m *Particle) GetVertex() *XYZTF {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *Particle) GetP() *XYZF {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *Particle) GetMass() float32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *Particle) GetCharge() int32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

type VarintParticle struct {
	// ProIO entry identifiers that point to parent Particles
	Parent []uint64 `protobuf:"varint,1,rep,packed,name=parent,proto3" json:"parent,omitempty"`
	// ProIO entry identifiers that point to child Particles
	Child []uint64 `protobuf:"varint,2,rep,packed,name=child,proto3" json:"child,omitempty"`
	// PDG code
	Pdg int32 `protobuf:"zigzag32,3,opt,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in um
	Vertex *XYZTI `protobuf:"bytes,4,opt,name=vertex,proto3" json:"vertex,omitempty"`
	// momentum in 10 keV
	P *XYZI `protobuf:"bytes,5,opt,name=p,proto3" json:"p,omitempty"`
	// mass in 10 keV
	Mass uint32 `protobuf:"varint,6,opt,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               int32    `protobuf:"zigzag32,7,opt,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarintParticle) Reset()         { *m = VarintParticle{} }
func (m *VarintParticle) String() string { return proto.CompactTextString(m) }
func (*VarintParticle) ProtoMessage()    {}
func (*VarintParticle) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{1}
}
func (m *VarintParticle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarintParticle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarintParticle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarintParticle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarintParticle.Merge(m, src)
}
func (m *VarintParticle) XXX_Size() int {
	return m.Size()
}
func (m *VarintParticle) XXX_DiscardUnknown() {
	xxx_messageInfo_VarintParticle.DiscardUnknown(m)
}

var xxx_messageInfo_VarintParticle proto.InternalMessageInfo

func (m *VarintParticle) GetParent() []uint64 {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *VarintParticle) GetChild() []uint64 {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *VarintParticle) GetPdg() int32 {
	if m != nil {
		return m.Pdg
	}
	return 0
}

func (m *VarintParticle) GetVertex() *XYZTI {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *VarintParticle) GetP() *XYZI {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *VarintParticle) GetMass() uint32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *VarintParticle) GetCharge() int32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

type PackedParticles struct {
	// parent particle entry indices
	Parent1 []uint64 `protobuf:"varint,1,rep,packed,name=parent1,proto3" json:"parent1,omitempty"`
	Parent2 []uint64 `protobuf:"varint,2,rep,packed,name=parent2,proto3" json:"parent2,omitempty"`
	// child particle entry indices
	Child1 []uint64 `protobuf:"varint,3,rep,packed,name=child1,proto3" json:"child1,omitempty"`
	Child2 []uint64 `protobuf:"varint,4,rep,packed,name=child2,proto3" json:"child2,omitempty"`
	// PDG code
	Pdg []int32 `protobuf:"zigzag32,5,rep,packed,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in mm
	X []float32 `protobuf:"fixed32,6,rep,packed,name=x,proto3" json:"x,omitempty"`
	Y []float32 `protobuf:"fixed32,7,rep,packed,name=y,proto3" json:"y,omitempty"`
	Z []float32 `protobuf:"fixed32,8,rep,packed,name=z,proto3" json:"z,omitempty"`
	T []float32 `protobuf:"fixed32,9,rep,packed,name=t,proto3" json:"t,omitempty"`
	// momentum in GeV
	Px []float32 `protobuf:"fixed32,10,rep,packed,name=px,proto3" json:"px,omitempty"`
	Py []float32 `protobuf:"fixed32,11,rep,packed,name=py,proto3" json:"py,omitempty"`
	Pz []float32 `protobuf:"fixed32,12,rep,packed,name=pz,proto3" json:"pz,omitempty"`
	// mass in GeV
	Mass []float32 `protobuf:"fixed32,13,rep,packed,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               []int32  `protobuf:"zigzag32,14,rep,packed,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PackedParticles) Reset()         { *m = PackedParticles{} }
func (m *PackedParticles) String() string { return proto.CompactTextString(m) }
func (*PackedParticles) ProtoMessage()    {}
func (*PackedParticles) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{2}
}
func (m *PackedParticles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackedParticles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackedParticles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackedParticles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackedParticles.Merge(m, src)
}
func (m *PackedParticles) XXX_Size() int {
	return m.Size()
}
func (m *PackedParticles) XXX_DiscardUnknown() {
	xxx_messageInfo_PackedParticles.DiscardUnknown(m)
}

var xxx_messageInfo_PackedParticles proto.InternalMessageInfo

func (m *PackedParticles) GetParent1() []uint64 {
	if m != nil {
		return m.Parent1
	}
	return nil
}

func (m *PackedParticles) GetParent2() []uint64 {
	if m != nil {
		return m.Parent2
	}
	return nil
}

func (m *PackedParticles) GetChild1() []uint64 {
	if m != nil {
		return m.Child1
	}
	return nil
}

func (m *PackedParticles) GetChild2() []uint64 {
	if m != nil {
		return m.Child2
	}
	return nil
}

func (m *PackedParticles) GetPdg() []int32 {
	if m != nil {
		return m.Pdg
	}
	return nil
}

func (m *PackedParticles) GetX() []float32 {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *PackedParticles) GetY() []float32 {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *PackedParticles) GetZ() []float32 {
	if m != nil {
		return m.Z
	}
	return nil
}

func (m *PackedParticles) GetT() []float32 {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *PackedParticles) GetPx() []float32 {
	if m != nil {
		return m.Px
	}
	return nil
}

func (m *PackedParticles) GetPy() []float32 {
	if m != nil {
		return m.Py
	}
	return nil
}

func (m *PackedParticles) GetPz() []float32 {
	if m != nil {
		return m.Pz
	}
	return nil
}

func (m *PackedParticles) GetMass() []float32 {
	if m != nil {
		return m.Mass
	}
	return nil
}

func (m *PackedParticles) GetCharge() []int32 {
	if m != nil {
		return m.Charge
	}
	return nil
}

type VarintPackedParticles struct {
	// parent particle entry indices
	Parent1 []uint64 `protobuf:"varint,1,rep,packed,name=parent1,proto3" json:"parent1,omitempty"`
	Parent2 []uint64 `protobuf:"varint,2,rep,packed,name=parent2,proto3" json:"parent2,omitempty"`
	// child particle entry indices
	Child1 []uint64 `protobuf:"varint,3,rep,packed,name=child1,proto3" json:"child1,omitempty"`
	Child2 []uint64 `protobuf:"varint,4,rep,packed,name=child2,proto3" json:"child2,omitempty"`
	// PDG code
	Pdg []int32 `protobuf:"zigzag32,5,rep,packed,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in um
	X []int32 `protobuf:"zigzag32,6,rep,packed,name=x,proto3" json:"x,omitempty"`
	Y []int32 `protobuf:"zigzag32,7,rep,packed,name=y,proto3" json:"y,omitempty"`
	Z []int32 `protobuf:"zigzag32,8,rep,packed,name=z,proto3" json:"z,omitempty"`
	T []int32 `protobuf:"zigzag32,9,rep,packed,name=t,proto3" json:"t,omitempty"`
	// momentum in 10 keV
	Px []int32 `protobuf:"zigzag32,10,rep,packed,name=px,proto3" json:"px,omitempty"`
	Py []int32 `protobuf:"zigzag32,11,rep,packed,name=py,proto3" json:"py,omitempty"`
	Pz []int32 `protobuf:"zigzag32,12,rep,packed,name=pz,proto3" json:"pz,omitempty"`
	// mass in 10 keV
	Mass []uint32 `protobuf:"varint,13,rep,packed,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               []int32  `protobuf:"zigzag32,14,rep,packed,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarintPackedParticles) Reset()         { *m = VarintPackedParticles{} }
func (m *VarintPackedParticles) String() string { return proto.CompactTextString(m) }
func (*VarintPackedParticles) ProtoMessage()    {}
func (*VarintPackedParticles) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{3}
}
func (m *VarintPackedParticles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarintPackedParticles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarintPackedParticles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarintPackedParticles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarintPackedParticles.Merge(m, src)
}
func (m *VarintPackedParticles) XXX_Size() int {
	return m.Size()
}
func (m *VarintPackedParticles) XXX_DiscardUnknown() {
	xxx_messageInfo_VarintPackedParticles.DiscardUnknown(m)
}

var xxx_messageInfo_VarintPackedParticles proto.InternalMessageInfo

func (m *VarintPackedParticles) GetParent1() []uint64 {
	if m != nil {
		return m.Parent1
	}
	return nil
}

func (m *VarintPackedParticles) GetParent2() []uint64 {
	if m != nil {
		return m.Parent2
	}
	return nil
}

func (m *VarintPackedParticles) GetChild1() []uint64 {
	if m != nil {
		return m.Child1
	}
	return nil
}

func (m *VarintPackedParticles) GetChild2() []uint64 {
	if m != nil {
		return m.Child2
	}
	return nil
}

func (m *VarintPackedParticles) GetPdg() []int32 {
	if m != nil {
		return m.Pdg
	}
	return nil
}

func (m *VarintPackedParticles) GetX() []int32 {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *VarintPackedParticles) GetY() []int32 {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *VarintPackedParticles) GetZ() []int32 {
	if m != nil {
		return m.Z
	}
	return nil
}

func (m *VarintPackedParticles) GetT() []int32 {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *VarintPackedParticles) GetPx() []int32 {
	if m != nil {
		return m.Px
	}
	return nil
}

func (m *VarintPackedParticles) GetPy() []int32 {
	if m != nil {
		return m.Py
	}
	return nil
}

func (m *VarintPackedParticles) GetPz() []int32 {
	if m != nil {
		return m.Pz
	}
	return nil
}

func (m *VarintPackedParticles) GetMass() []uint32 {
	if m != nil {
		return m.Mass
	}
	return nil
}

func (m *VarintPackedParticles) GetCharge() []int32 {
	if m != nil {
		return m.Charge
	}
	return nil
}

type XYZTD struct {
	X                    float64  `protobuf:"fixed64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float64  `protobuf:"fixed64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float64  `protobuf:"fixed64,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    float64  `protobuf:"fixed64,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTD) Reset()         { *m = XYZTD{} }
func (m *XYZTD) String() string { return proto.CompactTextString(m) }
func (*XYZTD) ProtoMessage()    {}
func (*XYZTD) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{4}
}
func (m *XYZTD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTD.Merge(m, src)
}
func (m *XYZTD) XXX_Size() int {
	return m.Size()
}
func (m *XYZTD) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTD.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTD proto.InternalMessageInfo

func (m *XYZTD) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTD) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTD) GetZ() float64 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTD) GetT() float64 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZTF struct {
	X                    float32  `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float32  `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float32  `protobuf:"fixed32,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    float32  `protobuf:"fixed32,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTF) Reset()         { *m = XYZTF{} }
func (m *XYZTF) String() string { return proto.CompactTextString(m) }
func (*XYZTF) ProtoMessage()    {}
func (*XYZTF) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{5}
}
func (m *XYZTF) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTF) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTF.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTF) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTF.Merge(m, src)
}
func (m *XYZTF) XXX_Size() int {
	return m.Size()
}
func (m *XYZTF) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTF.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTF proto.InternalMessageInfo

func (m *XYZTF) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTF) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTF) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTF) GetT() float32 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZTL struct {
	X                    int64    `protobuf:"zigzag64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int64    `protobuf:"zigzag64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int64    `protobuf:"zigzag64,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    int64    `protobuf:"zigzag64,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTL) Reset()         { *m = XYZTL{} }
func (m *XYZTL) String() string { return proto.CompactTextString(m) }
func (*XYZTL) ProtoMessage()    {}
func (*XYZTL) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{6}
}
func (m *XYZTL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTL.Merge(m, src)
}
func (m *XYZTL) XXX_Size() int {
	return m.Size()
}
func (m *XYZTL) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTL.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTL proto.InternalMessageInfo

func (m *XYZTL) GetX() int64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTL) GetY() int64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTL) GetZ() int64 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTL) GetT() int64 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZTI struct {
	X                    int32    `protobuf:"zigzag32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"zigzag32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int32    `protobuf:"zigzag32,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    int32    `protobuf:"zigzag32,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTI) Reset()         { *m = XYZTI{} }
func (m *XYZTI) String() string { return proto.CompactTextString(m) }
func (*XYZTI) ProtoMessage()    {}
func (*XYZTI) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{7}
}
func (m *XYZTI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTI.Merge(m, src)
}
func (m *XYZTI) XXX_Size() int {
	return m.Size()
}
func (m *XYZTI) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTI.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTI proto.InternalMessageInfo

func (m *XYZTI) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTI) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTI) GetZ() int32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTI) GetT() int32 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZD struct {
	X                    float64  `protobuf:"fixed64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float64  `protobuf:"fixed64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float64  `protobuf:"fixed64,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZD) Reset()         { *m = XYZD{} }
func (m *XYZD) String() string { return proto.CompactTextString(m) }
func (*XYZD) ProtoMessage()    {}
func (*XYZD) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{8}
}
func (m *XYZD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZD.Merge(m, src)
}
func (m *XYZD) XXX_Size() int {
	return m.Size()
}
func (m *XYZD) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZD.DiscardUnknown(m)
}

var xxx_messageInfo_XYZD proto.InternalMessageInfo

func (m *XYZD) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZD) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZD) GetZ() float64 {
	if m != nil {
		return m.Z
	}
	return 0
}

type XYZF struct {
	X                    float32  `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float32  `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float32  `protobuf:"fixed32,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZF) Reset()         { *m = XYZF{} }
func (m *XYZF) String() string { return proto.CompactTextString(m) }
func (*XYZF) ProtoMessage()    {}
func (*XYZF) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{9}
}
func (m *XYZF) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZF) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZF.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZF) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZF.Merge(m, src)
}
func (m *XYZF) XXX_Size() int {
	return m.Size()
}
func (m *XYZF) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZF.DiscardUnknown(m)
}

var xxx_messageInfo_XYZF proto.InternalMessageInfo

func (m *XYZF) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZF) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZF) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type XYZL struct {
	X                    int64    `protobuf:"zigzag64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int64    `protobuf:"zigzag64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int64    `protobuf:"zigzag64,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZL) Reset()         { *m = XYZL{} }
func (m *XYZL) String() string { return proto.CompactTextString(m) }
func (*XYZL) ProtoMessage()    {}
func (*XYZL) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{10}
}
func (m *XYZL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZL.Merge(m, src)
}
func (m *XYZL) XXX_Size() int {
	return m.Size()
}
func (m *XYZL) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZL.DiscardUnknown(m)
}

var xxx_messageInfo_XYZL proto.InternalMessageInfo

func (m *XYZL) GetX() int64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZL) GetY() int64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZL) GetZ() int64 {
	if m != nil {
		return m.Z
	}
	return 0
}

type XYZI struct {
	X                    int32    `protobuf:"zigzag32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"zigzag32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int32    `protobuf:"zigzag32,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZI) Reset()         { *m = XYZI{} }
func (m *XYZI) String() string { return proto.CompactTextString(m) }
func (*XYZI) ProtoMessage()    {}
func (*XYZI) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{11}
}
func (m *XYZI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZI.Merge(m, src)
}
func (m *XYZI) XXX_Size() int {
	return m.Size()
}
func (m *XYZI) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZI.DiscardUnknown(m)
}

var xxx_messageInfo_XYZI proto.InternalMessageInfo

func (m *XYZI) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZI) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZI) GetZ() int32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func init() {
	proto.RegisterType((*Particle)(nil), "proio.model.example.Particle")
	proto.RegisterType((*VarintParticle)(nil), "proio.model.example.VarintParticle")
	proto.RegisterType((*PackedParticles)(nil), "proio.model.example.PackedParticles")
	proto.RegisterType((*VarintPackedParticles)(nil), "proio.model.example.VarintPackedParticles")
	proto.RegisterType((*XYZTD)(nil), "proio.model.example.XYZTD")
	proto.RegisterType((*XYZTF)(nil), "proio.model.example.XYZTF")
	proto.RegisterType((*XYZTL)(nil), "proio.model.example.XYZTL")
	proto.RegisterType((*XYZTI)(nil), "proio.model.example.XYZTI")
	proto.RegisterType((*XYZD)(nil), "proio.model.example.XYZD")
	proto.RegisterType((*XYZF)(nil), "proio.model.example.XYZF")
	proto.RegisterType((*XYZL)(nil), "proio.model.example.XYZL")
	proto.RegisterType((*XYZI)(nil), "proio.model.example.XYZI")
}

func init() { proto.RegisterFile("proio/model/example/example.proto", fileDescriptor_9169c35b9136f42e) }

var fileDescriptor_9169c35b9136f42e = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x95, 0x4f, 0x8b, 0xd3, 0x40,
	0x18, 0xc6, 0x9d, 0x49, 0xda, 0xac, 0x6f, 0xb7, 0xd5, 0x19, 0xff, 0x30, 0x7a, 0x28, 0xb1, 0x17,
	0x73, 0x4a, 0xdd, 0xf8, 0x01, 0x84, 0x45, 0x0b, 0x05, 0x0f, 0x4b, 0x10, 0xd9, 0xed, 0x2d, 0x36,
	0xc3, 0x6e, 0x30, 0xdd, 0x0c, 0x69, 0x90, 0xb4, 0x9f, 0x44, 0xf0, 0xe4, 0xb7, 0xf1, 0x28, 0x78,
	0xf2, 0x26, 0xf5, 0x8b, 0x48, 0xe6, 0x4f, 0xdb, 0xa9, 0xca, 0x92, 0x93, 0x9e, 0x3a, 0xbf, 0x77,
	0xde, 0x79, 0xfa, 0x3e, 0x4f, 0xc2, 0x04, 0x9e, 0x88, 0xb2, 0xc8, 0x8a, 0xf1, 0xa2, 0x48, 0x79,
	0x3e, 0xe6, 0x75, 0xb2, 0x10, 0x39, 0x37, 0xbf, 0xa1, 0x28, 0x8b, 0xaa, 0xa0, 0xf7, 0x64, 0x4b,
	0x28, 0x5b, 0x42, 0xbd, 0x35, 0xfa, 0x86, 0xe0, 0xe8, 0x2c, 0x29, 0xab, 0x6c, 0x9e, 0x73, 0xfa,
	0x10, 0xba, 0x22, 0x29, 0xf9, 0x75, 0xc5, 0x90, 0xef, 0x04, 0x6e, 0xac, 0x89, 0xde, 0x87, 0xce,
	0xfc, 0x2a, 0xcb, 0x53, 0x86, 0x65, 0x59, 0x01, 0xbd, 0x0b, 0x8e, 0x48, 0x2f, 0x99, 0xe3, 0xa3,
	0x80, 0xc4, 0xcd, 0x92, 0x46, 0xd0, 0xfd, 0xc0, 0xcb, 0x8a, 0xd7, 0xcc, 0xf5, 0x51, 0xd0, 0x8b,
	0x1e, 0x87, 0x7f, 0xf8, 0xcb, 0xf0, 0xfc, 0x62, 0xf6, 0x66, 0x12, 0xeb, 0x4e, 0xfa, 0x14, 0x90,
	0x60, 0x1d, 0xd9, 0xfe, 0xe8, 0x6f, 0xed, 0x93, 0x18, 0x09, 0x4a, 0xc1, 0x5d, 0x24, 0xcb, 0x25,
	0xeb, 0xfa, 0x28, 0xc0, 0xb1, 0x5c, 0x37, 0x03, 0xcf, 0xaf, 0x92, 0xf2, 0x92, 0x33, 0x4f, 0x4e,
	0xa1, 0x69, 0xf4, 0x1d, 0xc1, 0xe0, 0x6d, 0x52, 0x66, 0xd7, 0xd5, 0x3f, 0xf0, 0x36, 0x6d, 0xe5,
	0x6d, 0x7a, 0xe8, 0xad, 0x7f, 0x83, 0xb7, 0x4f, 0x18, 0xee, 0x9c, 0x25, 0xf3, 0xf7, 0x3c, 0x35,
	0xde, 0x96, 0x94, 0x81, 0xa7, 0xec, 0x9c, 0x68, 0x77, 0x06, 0x77, 0x3b, 0x91, 0x36, 0x68, 0x50,
	0xe9, 0x67, 0x79, 0x7a, 0xc2, 0x1c, 0x15, 0x88, 0xa2, 0x6d, 0x3d, 0x62, 0xee, 0x5e, 0x3d, 0x32,
	0x91, 0x74, 0x7c, 0xc7, 0x44, 0x72, 0x0c, 0xa8, 0x66, 0x5d, 0xdf, 0x09, 0x70, 0x8c, 0xea, 0x86,
	0x56, 0xcc, 0x53, 0xb4, 0x6a, 0x68, 0xcd, 0x8e, 0x14, 0xad, 0x1b, 0xaa, 0xd8, 0x6d, 0x45, 0x15,
	0x1d, 0x00, 0x16, 0x35, 0x03, 0x89, 0x58, 0xd4, 0x92, 0x57, 0xac, 0xa7, 0x79, 0x25, 0x79, 0xcd,
	0x8e, 0x35, 0xaf, 0xb7, 0xe9, 0xf4, 0x65, 0xe5, 0x30, 0x9d, 0x81, 0x1c, 0xc8, 0xa4, 0xf3, 0x19,
	0xc3, 0x03, 0xf3, 0xe4, 0xff, 0xab, 0x8c, 0x88, 0x95, 0x11, 0xb1, 0x32, 0x22, 0x56, 0x46, 0xc4,
	0xce, 0x88, 0x1c, 0x64, 0x44, 0x0e, 0x32, 0x22, 0xbf, 0x65, 0xd4, 0xbf, 0x21, 0xa3, 0x17, 0xd0,
	0x69, 0xde, 0xd3, 0x97, 0x6a, 0x38, 0xe4, 0xa3, 0x00, 0x6d, 0x87, 0xc3, 0x8a, 0xf4, 0x70, 0x8e,
	0x22, 0x3d, 0x9c, 0xab, 0xa8, 0x32, 0x02, 0x93, 0x9d, 0x00, 0xb6, 0x04, 0xb0, 0x25, 0x80, 0x2d,
	0x01, 0xbc, 0x27, 0xf0, 0x7a, 0x27, 0x40, 0x2d, 0x01, 0x6a, 0x09, 0x50, 0x4b, 0x80, 0xee, 0x09,
	0x4c, 0x77, 0x02, 0xc4, 0x12, 0x20, 0x96, 0x00, 0xb1, 0x04, 0x9a, 0x7c, 0x47, 0xcf, 0xc0, 0x3d,
	0xbf, 0x98, 0xb5, 0x88, 0x40, 0x9f, 0x68, 0xe1, 0x59, 0x9f, 0x68, 0x61, 0x52, 0x9f, 0x68, 0xe1,
	0xea, 0x74, 0xfc, 0x65, 0x33, 0x44, 0x5f, 0x37, 0x43, 0xf4, 0x63, 0x33, 0x44, 0x1f, 0x7f, 0x0e,
	0x6f, 0x41, 0x6f, 0xef, 0xa2, 0x39, 0xf5, 0x5e, 0xa9, 0x9b, 0x66, 0xe6, 0xe9, 0x2b, 0xe7, 0x5d,
	0x57, 0x7e, 0x0c, 0x9e, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xd1, 0xc3, 0x51, 0x45, 0x31, 0x06,
	0x00, 0x00,
}

func (m *Particle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Particle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Particle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Charge != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Charge)<<1)^uint32((m.Charge>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Mass != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Mass))))
		i--
		dAtA[i] = 0x35
	}
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExample(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Vertex != nil {
		{
			size, err := m.Vertex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExample(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Pdg != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Pdg)<<1)^uint32((m.Pdg>>31))))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Child) > 0 {
		dAtA4 := make([]byte, len(m.Child)*10)
		var j3 int
		for _, num := range m.Child {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintExample(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Parent) > 0 {
		dAtA6 := make([]byte, len(m.Parent)*10)
		var j5 int
		for _, num := range m.Parent {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintExample(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VarintParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarintParticle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VarintParticle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Charge != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Charge)<<1)^uint32((m.Charge>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Mass != 0 {
		i = encodeVarintExample(dAtA, i, uint64(m.Mass))
		i--
		dAtA[i] = 0x30
	}
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExample(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Vertex != nil {
		{
			size, err := m.Vertex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExample(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Pdg != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Pdg)<<1)^uint32((m.Pdg>>31))))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Child) > 0 {
		dAtA10 := make([]byte, len(m.Child)*10)
		var j9 int
		for _, num := range m.Child {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintExample(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Parent) > 0 {
		dAtA12 := make([]byte, len(m.Parent)*10)
		var j11 int
		for _, num := range m.Parent {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintExample(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PackedParticles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackedParticles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PackedParticles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Charge) > 0 {
		dAtA13 := make([]byte, len(m.Charge)*5)
		var j14 int
		for _, num := range m.Charge {
			x15 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x15 >= 1<<7 {
				dAtA13[j14] = uint8(uint64(x15)&0x7f | 0x80)
				j14++
				x15 >>= 7
			}
			dAtA13[j14] = uint8(x15)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA13[:j14])
		i = encodeVarintExample(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Mass) > 0 {
		for iNdEx := len(m.Mass) - 1; iNdEx >= 0; iNdEx-- {
			f16 := math.Float32bits(float32(m.Mass[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f16))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.Mass)*4))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Pz) > 0 {
		for iNdEx := len(m.Pz) - 1; iNdEx >= 0; iNdEx-- {
			f17 := math.Float32bits(float32(m.Pz[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f17))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.Pz)*4))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Py) > 0 {
		for iNdEx := len(m.Py) - 1; iNdEx >= 0; iNdEx-- {
			f18 := math.Float32bits(float32(m.Py[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f18))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.Py)*4))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Px) > 0 {
		for iNdEx := len(m.Px) - 1; iNdEx >= 0; iNdEx-- {
			f19 := math.Float32bits(float32(m.Px[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f19))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.Px)*4))
		i--
		dAtA[i] = 0x52
	}
	if len(m.T) > 0 {
		for iNdEx := len(m.T) - 1; iNdEx >= 0; iNdEx-- {
			f20 := math.Float32bits(float32(m.T[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f20))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.T)*4))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Z) > 0 {
		for iNdEx := len(m.Z) - 1; iNdEx >= 0; iNdEx-- {
			f21 := math.Float32bits(float32(m.Z[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f21))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.Z)*4))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Y) > 0 {
		for iNdEx := len(m.Y) - 1; iNdEx >= 0; iNdEx-- {
			f22 := math.Float32bits(float32(m.Y[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f22))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.Y)*4))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.X) > 0 {
		for iNdEx := len(m.X) - 1; iNdEx >= 0; iNdEx-- {
			f23 := math.Float32bits(float32(m.X[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f23))
		}
		i = encodeVarintExample(dAtA, i, uint64(len(m.X)*4))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Pdg) > 0 {
		dAtA24 := make([]byte, len(m.Pdg)*5)
		var j25 int
		for _, num := range m.Pdg {
			x26 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x26 >= 1<<7 {
				dAtA24[j25] = uint8(uint64(x26)&0x7f | 0x80)
				j25++
				x26 >>= 7
			}
			dAtA24[j25] = uint8(x26)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA24[:j25])
		i = encodeVarintExample(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Child2) > 0 {
		dAtA28 := make([]byte, len(m.Child2)*10)
		var j27 int
		for _, num := range m.Child2 {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintExample(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Child1) > 0 {
		dAtA30 := make([]byte, len(m.Child1)*10)
		var j29 int
		for _, num := range m.Child1 {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintExample(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Parent2) > 0 {
		dAtA32 := make([]byte, len(m.Parent2)*10)
		var j31 int
		for _, num := range m.Parent2 {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintExample(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Parent1) > 0 {
		dAtA34 := make([]byte, len(m.Parent1)*10)
		var j33 int
		for _, num := range m.Parent1 {
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintExample(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VarintPackedParticles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarintPackedParticles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VarintPackedParticles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Charge) > 0 {
		dAtA35 := make([]byte, len(m.Charge)*5)
		var j36 int
		for _, num := range m.Charge {
			x37 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x37 >= 1<<7 {
				dAtA35[j36] = uint8(uint64(x37)&0x7f | 0x80)
				j36++
				x37 >>= 7
			}
			dAtA35[j36] = uint8(x37)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA35[:j36])
		i = encodeVarintExample(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Mass) > 0 {
		dAtA39 := make([]byte, len(m.Mass)*10)
		var j38 int
		for _, num := range m.Mass {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintExample(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Pz) > 0 {
		dAtA40 := make([]byte, len(m.Pz)*5)
		var j41 int
		for _, num := range m.Pz {
			x42 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x42 >= 1<<7 {
				dAtA40[j41] = uint8(uint64(x42)&0x7f | 0x80)
				j41++
				x42 >>= 7
			}
			dAtA40[j41] = uint8(x42)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA40[:j41])
		i = encodeVarintExample(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Py) > 0 {
		dAtA43 := make([]byte, len(m.Py)*5)
		var j44 int
		for _, num := range m.Py {
			x45 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x45 >= 1<<7 {
				dAtA43[j44] = uint8(uint64(x45)&0x7f | 0x80)
				j44++
				x45 >>= 7
			}
			dAtA43[j44] = uint8(x45)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA43[:j44])
		i = encodeVarintExample(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Px) > 0 {
		dAtA46 := make([]byte, len(m.Px)*5)
		var j47 int
		for _, num := range m.Px {
			x48 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x48 >= 1<<7 {
				dAtA46[j47] = uint8(uint64(x48)&0x7f | 0x80)
				j47++
				x48 >>= 7
			}
			dAtA46[j47] = uint8(x48)
			j47++
		}
		i -= j47
		copy(dAtA[i:], dAtA46[:j47])
		i = encodeVarintExample(dAtA, i, uint64(j47))
		i--
		dAtA[i] = 0x52
	}
	if len(m.T) > 0 {
		dAtA49 := make([]byte, len(m.T)*5)
		var j50 int
		for _, num := range m.T {
			x51 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x51 >= 1<<7 {
				dAtA49[j50] = uint8(uint64(x51)&0x7f | 0x80)
				j50++
				x51 >>= 7
			}
			dAtA49[j50] = uint8(x51)
			j50++
		}
		i -= j50
		copy(dAtA[i:], dAtA49[:j50])
		i = encodeVarintExample(dAtA, i, uint64(j50))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Z) > 0 {
		dAtA52 := make([]byte, len(m.Z)*5)
		var j53 int
		for _, num := range m.Z {
			x54 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x54 >= 1<<7 {
				dAtA52[j53] = uint8(uint64(x54)&0x7f | 0x80)
				j53++
				x54 >>= 7
			}
			dAtA52[j53] = uint8(x54)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA52[:j53])
		i = encodeVarintExample(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Y) > 0 {
		dAtA55 := make([]byte, len(m.Y)*5)
		var j56 int
		for _, num := range m.Y {
			x57 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x57 >= 1<<7 {
				dAtA55[j56] = uint8(uint64(x57)&0x7f | 0x80)
				j56++
				x57 >>= 7
			}
			dAtA55[j56] = uint8(x57)
			j56++
		}
		i -= j56
		copy(dAtA[i:], dAtA55[:j56])
		i = encodeVarintExample(dAtA, i, uint64(j56))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.X) > 0 {
		dAtA58 := make([]byte, len(m.X)*5)
		var j59 int
		for _, num := range m.X {
			x60 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x60 >= 1<<7 {
				dAtA58[j59] = uint8(uint64(x60)&0x7f | 0x80)
				j59++
				x60 >>= 7
			}
			dAtA58[j59] = uint8(x60)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA58[:j59])
		i = encodeVarintExample(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Pdg) > 0 {
		dAtA61 := make([]byte, len(m.Pdg)*5)
		var j62 int
		for _, num := range m.Pdg {
			x63 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x63 >= 1<<7 {
				dAtA61[j62] = uint8(uint64(x63)&0x7f | 0x80)
				j62++
				x63 >>= 7
			}
			dAtA61[j62] = uint8(x63)
			j62++
		}
		i -= j62
		copy(dAtA[i:], dAtA61[:j62])
		i = encodeVarintExample(dAtA, i, uint64(j62))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Child2) > 0 {
		dAtA65 := make([]byte, len(m.Child2)*10)
		var j64 int
		for _, num := range m.Child2 {
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintExample(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Child1) > 0 {
		dAtA67 := make([]byte, len(m.Child1)*10)
		var j66 int
		for _, num := range m.Child1 {
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintExample(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Parent2) > 0 {
		dAtA69 := make([]byte, len(m.Parent2)*10)
		var j68 int
		for _, num := range m.Parent2 {
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintExample(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Parent1) > 0 {
		dAtA71 := make([]byte, len(m.Parent1)*10)
		var j70 int
		for _, num := range m.Parent1 {
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		i -= j70
		copy(dAtA[i:], dAtA71[:j70])
		i = encodeVarintExample(dAtA, i, uint64(j70))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *XYZTD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTD) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZTD) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.T != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.T))))
		i--
		dAtA[i] = 0x21
	}
	if m.Z != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Z))))
		i--
		dAtA[i] = 0x19
	}
	if m.Y != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Y))))
		i--
		dAtA[i] = 0x11
	}
	if m.X != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *XYZTF) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTF) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZTF) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.T != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.T))))
		i--
		dAtA[i] = 0x25
	}
	if m.Z != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x15
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *XYZTL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.T != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.T)<<1)^uint64((m.T>>63))))
		i--
		dAtA[i] = 0x20
	}
	if m.Z != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Z)<<1)^uint64((m.Z>>63))))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Y)<<1)^uint64((m.Y>>63))))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.X)<<1)^uint64((m.X>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *XYZTI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZTI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.T != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.T)<<1)^uint32((m.T>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Z != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Z)<<1)^uint32((m.Z>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Y)<<1)^uint32((m.Y>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.X)<<1)^uint32((m.X>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *XYZD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZD) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZD) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Z != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Z))))
		i--
		dAtA[i] = 0x19
	}
	if m.Y != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Y))))
		i--
		dAtA[i] = 0x11
	}
	if m.X != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *XYZF) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZF) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZF) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Z != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x15
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *XYZL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Z != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Z)<<1)^uint64((m.Z>>63))))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Y)<<1)^uint64((m.Y>>63))))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.X)<<1)^uint64((m.X>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *XYZI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XYZI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Z != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Z)<<1)^uint32((m.Z>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Y)<<1)^uint32((m.Y>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.X)<<1)^uint32((m.X>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintExample(dAtA []byte, offset int, v uint64) int {
	offset -= sovExample(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Particle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent) > 0 {
		l = 0
		for _, e := range m.Parent {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child) > 0 {
		l = 0
		for _, e := range m.Child {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.Pdg != 0 {
		n += 1 + sozExample(uint64(m.Pdg))
	}
	if m.Vertex != nil {
		l = m.Vertex.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.Mass != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 1 + sozExample(uint64(m.Charge))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarintParticle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent) > 0 {
		l = 0
		for _, e := range m.Parent {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child) > 0 {
		l = 0
		for _, e := range m.Child {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.Pdg != 0 {
		n += 1 + sozExample(uint64(m.Pdg))
	}
	if m.Vertex != nil {
		l = m.Vertex.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.Mass != 0 {
		n += 1 + sovExample(uint64(m.Mass))
	}
	if m.Charge != 0 {
		n += 1 + sozExample(uint64(m.Charge))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PackedParticles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent1) > 0 {
		l = 0
		for _, e := range m.Parent1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Parent2) > 0 {
		l = 0
		for _, e := range m.Parent2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child1) > 0 {
		l = 0
		for _, e := range m.Child1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child2) > 0 {
		l = 0
		for _, e := range m.Child2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Pdg) > 0 {
		l = 0
		for _, e := range m.Pdg {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.X) > 0 {
		n += 1 + sovExample(uint64(len(m.X)*4)) + len(m.X)*4
	}
	if len(m.Y) > 0 {
		n += 1 + sovExample(uint64(len(m.Y)*4)) + len(m.Y)*4
	}
	if len(m.Z) > 0 {
		n += 1 + sovExample(uint64(len(m.Z)*4)) + len(m.Z)*4
	}
	if len(m.T) > 0 {
		n += 1 + sovExample(uint64(len(m.T)*4)) + len(m.T)*4
	}
	if len(m.Px) > 0 {
		n += 1 + sovExample(uint64(len(m.Px)*4)) + len(m.Px)*4
	}
	if len(m.Py) > 0 {
		n += 1 + sovExample(uint64(len(m.Py)*4)) + len(m.Py)*4
	}
	if len(m.Pz) > 0 {
		n += 1 + sovExample(uint64(len(m.Pz)*4)) + len(m.Pz)*4
	}
	if len(m.Mass) > 0 {
		n += 1 + sovExample(uint64(len(m.Mass)*4)) + len(m.Mass)*4
	}
	if len(m.Charge) > 0 {
		l = 0
		for _, e := range m.Charge {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarintPackedParticles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent1) > 0 {
		l = 0
		for _, e := range m.Parent1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Parent2) > 0 {
		l = 0
		for _, e := range m.Parent2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child1) > 0 {
		l = 0
		for _, e := range m.Child1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child2) > 0 {
		l = 0
		for _, e := range m.Child2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Pdg) > 0 {
		l = 0
		for _, e := range m.Pdg {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.X) > 0 {
		l = 0
		for _, e := range m.X {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Y) > 0 {
		l = 0
		for _, e := range m.Y {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Z) > 0 {
		l = 0
		for _, e := range m.Z {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.T) > 0 {
		l = 0
		for _, e := range m.T {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Px) > 0 {
		l = 0
		for _, e := range m.Px {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Py) > 0 {
		l = 0
		for _, e := range m.Py {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Pz) > 0 {
		l = 0
		for _, e := range m.Pz {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Mass) > 0 {
		l = 0
		for _, e := range m.Mass {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Charge) > 0 {
		l = 0
		for _, e := range m.Charge {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	if m.Z != 0 {
		n += 9
	}
	if m.T != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTF) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	if m.T != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.T != 0 {
		n += 1 + sozExample(uint64(m.T))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.T != 0 {
		n += 1 + sozExample(uint64(m.T))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	if m.Z != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZF) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExample(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExample(x uint64) (n int) {
	return sovExample(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Particle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Particle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Particle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent = append(m.Parent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent) == 0 {
					m.Parent = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent = append(m.Parent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child = append(m.Child, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child) == 0 {
					m.Child = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child = append(m.Child, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Pdg = v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExample
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vertex == nil {
				m.Vertex = &XYZTF{}
			}
			if err := m.Vertex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExample
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &XYZF{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Mass = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Charge = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarintParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarintParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarintParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent = append(m.Parent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent) == 0 {
					m.Parent = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent = append(m.Parent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child = append(m.Child, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child) == 0 {
					m.Child = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child = append(m.Child, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Pdg = v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExample
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vertex == nil {
				m.Vertex = &XYZTI{}
			}
			if err := m.Vertex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExample
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &XYZI{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			m.Mass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mass |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Charge = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackedParticles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackedParticles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackedParticles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent1 = append(m.Parent1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent1) == 0 {
					m.Parent1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent1 = append(m.Parent1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent1", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent2 = append(m.Parent2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent2) == 0 {
					m.Parent2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent2 = append(m.Parent2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child1 = append(m.Child1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child1) == 0 {
					m.Child1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child1 = append(m.Child1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child1", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child2 = append(m.Child2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child2) == 0 {
					m.Child2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child2 = append(m.Child2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child2", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Pdg = append(m.Pdg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Pdg) == 0 {
					m.Pdg = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Pdg = append(m.Pdg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.X = append(m.X, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.X) == 0 {
					m.X = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.X = append(m.X, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Y = append(m.Y, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Y) == 0 {
					m.Y = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Y = append(m.Y, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Z = append(m.Z, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Z) == 0 {
					m.Z = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Z = append(m.Z, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.T = append(m.T, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.T) == 0 {
					m.T = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.T = append(m.T, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
		case 10:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Px = append(m.Px, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Px) == 0 {
					m.Px = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Px = append(m.Px, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Px", wireType)
			}
		case 11:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Py = append(m.Py, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Py) == 0 {
					m.Py = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Py = append(m.Py, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Py", wireType)
			}
		case 12:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pz = append(m.Pz, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Pz) == 0 {
					m.Pz = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pz = append(m.Pz, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pz", wireType)
			}
		case 13:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Mass = append(m.Mass, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Mass) == 0 {
					m.Mass = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Mass = append(m.Mass, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Charge = append(m.Charge, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Charge) == 0 {
					m.Charge = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Charge = append(m.Charge, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarintPackedParticles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarintPackedParticles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarintPackedParticles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent1 = append(m.Parent1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent1) == 0 {
					m.Parent1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent1 = append(m.Parent1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent1", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent2 = append(m.Parent2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent2) == 0 {
					m.Parent2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent2 = append(m.Parent2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child1 = append(m.Child1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child1) == 0 {
					m.Child1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child1 = append(m.Child1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child1", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child2 = append(m.Child2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child2) == 0 {
					m.Child2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child2 = append(m.Child2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child2", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Pdg = append(m.Pdg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Pdg) == 0 {
					m.Pdg = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Pdg = append(m.Pdg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.X = append(m.X, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.X) == 0 {
					m.X = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.X = append(m.X, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Y = append(m.Y, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Y) == 0 {
					m.Y = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Y = append(m.Y, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Z = append(m.Z, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Z) == 0 {
					m.Z = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Z = append(m.Z, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.T = append(m.T, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.T) == 0 {
					m.T = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.T = append(m.T, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Px = append(m.Px, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Px) == 0 {
					m.Px = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Px = append(m.Px, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Px", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Py = append(m.Py, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Py) == 0 {
					m.Py = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Py = append(m.Py, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Py", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Pz = append(m.Pz, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Pz) == 0 {
					m.Pz = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Pz = append(m.Pz, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pz", wireType)
			}
		case 13:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mass = append(m.Mass, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mass) == 0 {
					m.Mass = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mass = append(m.Mass, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Charge = append(m.Charge, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExample
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Charge) == 0 {
					m.Charge = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Charge = append(m.Charge, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Y = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Z = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.T = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTF) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTF: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTF: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.T = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.X = int64(v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Y = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Z = int64(v)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.T = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.X = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Y = v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Z = v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.T = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Y = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Z = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZF) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZF: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZF: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.X = int64(v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Y = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Z = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.X = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Y = v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Z = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExample(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExample
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExample
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExample
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExample
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupExample
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthExample
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthExample        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExample          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupExample = fmt.Errorf("proto: unexpected end of group")
)
