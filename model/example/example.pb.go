// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proio/model/example/example.proto

package example

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Particle struct {
	// ProIO entry identifiers that point to parent Particles
	Parent []uint64 `protobuf:"varint,1,rep,packed,name=parent,proto3" json:"parent,omitempty"`
	// ProIO entry identifiers that point to child Particles
	Child []uint64 `protobuf:"varint,2,rep,packed,name=child,proto3" json:"child,omitempty"`
	// PDG code
	Pdg int32 `protobuf:"zigzag32,3,opt,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in mm
	Vertex *XYZTF `protobuf:"bytes,4,opt,name=vertex,proto3" json:"vertex,omitempty"`
	// momentum in GeV
	P *XYZF `protobuf:"bytes,5,opt,name=p,proto3" json:"p,omitempty"`
	// mass in GeV
	Mass float32 `protobuf:"fixed32,6,opt,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               int32    `protobuf:"zigzag32,7,opt,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Particle) Reset()         { *m = Particle{} }
func (m *Particle) String() string { return proto.CompactTextString(m) }
func (*Particle) ProtoMessage()    {}
func (*Particle) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{0}
}
func (m *Particle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Particle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Particle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Particle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Particle.Merge(m, src)
}
func (m *Particle) XXX_Size() int {
	return m.Size()
}
func (m *Particle) XXX_DiscardUnknown() {
	xxx_messageInfo_Particle.DiscardUnknown(m)
}

var xxx_messageInfo_Particle proto.InternalMessageInfo

func (m *Particle) GetParent() []uint64 {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Particle) GetChild() []uint64 {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *Particle) GetPdg() int32 {
	if m != nil {
		return m.Pdg
	}
	return 0
}

func (m *Particle) GetVertex() *XYZTF {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *Particle) GetP() *XYZF {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *Particle) GetMass() float32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *Particle) GetCharge() int32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

type VarintParticle struct {
	// ProIO entry identifiers that point to parent Particles
	Parent []uint64 `protobuf:"varint,1,rep,packed,name=parent,proto3" json:"parent,omitempty"`
	// ProIO entry identifiers that point to child Particles
	Child []uint64 `protobuf:"varint,2,rep,packed,name=child,proto3" json:"child,omitempty"`
	// PDG code
	Pdg int32 `protobuf:"zigzag32,3,opt,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in um
	Vertex *XYZTI `protobuf:"bytes,4,opt,name=vertex,proto3" json:"vertex,omitempty"`
	// momentum in 10 keV
	P *XYZI `protobuf:"bytes,5,opt,name=p,proto3" json:"p,omitempty"`
	// mass in 10 keV
	Mass uint32 `protobuf:"varint,6,opt,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               int32    `protobuf:"zigzag32,7,opt,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarintParticle) Reset()         { *m = VarintParticle{} }
func (m *VarintParticle) String() string { return proto.CompactTextString(m) }
func (*VarintParticle) ProtoMessage()    {}
func (*VarintParticle) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{1}
}
func (m *VarintParticle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarintParticle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarintParticle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarintParticle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarintParticle.Merge(m, src)
}
func (m *VarintParticle) XXX_Size() int {
	return m.Size()
}
func (m *VarintParticle) XXX_DiscardUnknown() {
	xxx_messageInfo_VarintParticle.DiscardUnknown(m)
}

var xxx_messageInfo_VarintParticle proto.InternalMessageInfo

func (m *VarintParticle) GetParent() []uint64 {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *VarintParticle) GetChild() []uint64 {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *VarintParticle) GetPdg() int32 {
	if m != nil {
		return m.Pdg
	}
	return 0
}

func (m *VarintParticle) GetVertex() *XYZTI {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *VarintParticle) GetP() *XYZI {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *VarintParticle) GetMass() uint32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *VarintParticle) GetCharge() int32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

type PackedParticles struct {
	// parent particle entry indices
	Parent1 []uint64 `protobuf:"varint,1,rep,packed,name=parent1,proto3" json:"parent1,omitempty"`
	Parent2 []uint64 `protobuf:"varint,2,rep,packed,name=parent2,proto3" json:"parent2,omitempty"`
	// child particle entry indices
	Child1 []uint64 `protobuf:"varint,3,rep,packed,name=child1,proto3" json:"child1,omitempty"`
	Child2 []uint64 `protobuf:"varint,4,rep,packed,name=child2,proto3" json:"child2,omitempty"`
	// PDG code
	Pdg []int32 `protobuf:"zigzag32,5,rep,packed,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in mm
	X []float32 `protobuf:"fixed32,6,rep,packed,name=x,proto3" json:"x,omitempty"`
	Y []float32 `protobuf:"fixed32,7,rep,packed,name=y,proto3" json:"y,omitempty"`
	Z []float32 `protobuf:"fixed32,8,rep,packed,name=z,proto3" json:"z,omitempty"`
	T []float32 `protobuf:"fixed32,9,rep,packed,name=t,proto3" json:"t,omitempty"`
	// momentum in GeV
	Px []float32 `protobuf:"fixed32,10,rep,packed,name=px,proto3" json:"px,omitempty"`
	Py []float32 `protobuf:"fixed32,11,rep,packed,name=py,proto3" json:"py,omitempty"`
	Pz []float32 `protobuf:"fixed32,12,rep,packed,name=pz,proto3" json:"pz,omitempty"`
	// mass in GeV
	Mass []float32 `protobuf:"fixed32,13,rep,packed,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               []int32  `protobuf:"zigzag32,14,rep,packed,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PackedParticles) Reset()         { *m = PackedParticles{} }
func (m *PackedParticles) String() string { return proto.CompactTextString(m) }
func (*PackedParticles) ProtoMessage()    {}
func (*PackedParticles) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{2}
}
func (m *PackedParticles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackedParticles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackedParticles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackedParticles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackedParticles.Merge(m, src)
}
func (m *PackedParticles) XXX_Size() int {
	return m.Size()
}
func (m *PackedParticles) XXX_DiscardUnknown() {
	xxx_messageInfo_PackedParticles.DiscardUnknown(m)
}

var xxx_messageInfo_PackedParticles proto.InternalMessageInfo

func (m *PackedParticles) GetParent1() []uint64 {
	if m != nil {
		return m.Parent1
	}
	return nil
}

func (m *PackedParticles) GetParent2() []uint64 {
	if m != nil {
		return m.Parent2
	}
	return nil
}

func (m *PackedParticles) GetChild1() []uint64 {
	if m != nil {
		return m.Child1
	}
	return nil
}

func (m *PackedParticles) GetChild2() []uint64 {
	if m != nil {
		return m.Child2
	}
	return nil
}

func (m *PackedParticles) GetPdg() []int32 {
	if m != nil {
		return m.Pdg
	}
	return nil
}

func (m *PackedParticles) GetX() []float32 {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *PackedParticles) GetY() []float32 {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *PackedParticles) GetZ() []float32 {
	if m != nil {
		return m.Z
	}
	return nil
}

func (m *PackedParticles) GetT() []float32 {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *PackedParticles) GetPx() []float32 {
	if m != nil {
		return m.Px
	}
	return nil
}

func (m *PackedParticles) GetPy() []float32 {
	if m != nil {
		return m.Py
	}
	return nil
}

func (m *PackedParticles) GetPz() []float32 {
	if m != nil {
		return m.Pz
	}
	return nil
}

func (m *PackedParticles) GetMass() []float32 {
	if m != nil {
		return m.Mass
	}
	return nil
}

func (m *PackedParticles) GetCharge() []int32 {
	if m != nil {
		return m.Charge
	}
	return nil
}

type VarintPackedParticles struct {
	// parent particle entry indices
	Parent1 []uint64 `protobuf:"varint,1,rep,packed,name=parent1,proto3" json:"parent1,omitempty"`
	Parent2 []uint64 `protobuf:"varint,2,rep,packed,name=parent2,proto3" json:"parent2,omitempty"`
	// child particle entry indices
	Child1 []uint64 `protobuf:"varint,3,rep,packed,name=child1,proto3" json:"child1,omitempty"`
	Child2 []uint64 `protobuf:"varint,4,rep,packed,name=child2,proto3" json:"child2,omitempty"`
	// PDG code
	Pdg []int32 `protobuf:"zigzag32,5,rep,packed,name=pdg,proto3" json:"pdg,omitempty"`
	// vertex in um
	X []int32 `protobuf:"zigzag32,6,rep,packed,name=x,proto3" json:"x,omitempty"`
	Y []int32 `protobuf:"zigzag32,7,rep,packed,name=y,proto3" json:"y,omitempty"`
	Z []int32 `protobuf:"zigzag32,8,rep,packed,name=z,proto3" json:"z,omitempty"`
	T []int32 `protobuf:"zigzag32,9,rep,packed,name=t,proto3" json:"t,omitempty"`
	// momentum in 10 keV
	Px []int32 `protobuf:"zigzag32,10,rep,packed,name=px,proto3" json:"px,omitempty"`
	Py []int32 `protobuf:"zigzag32,11,rep,packed,name=py,proto3" json:"py,omitempty"`
	Pz []int32 `protobuf:"zigzag32,12,rep,packed,name=pz,proto3" json:"pz,omitempty"`
	// mass in 10 keV
	Mass []uint32 `protobuf:"varint,13,rep,packed,name=mass,proto3" json:"mass,omitempty"`
	// charge in units of e/3
	Charge               []int32  `protobuf:"zigzag32,14,rep,packed,name=charge,proto3" json:"charge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarintPackedParticles) Reset()         { *m = VarintPackedParticles{} }
func (m *VarintPackedParticles) String() string { return proto.CompactTextString(m) }
func (*VarintPackedParticles) ProtoMessage()    {}
func (*VarintPackedParticles) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{3}
}
func (m *VarintPackedParticles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarintPackedParticles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarintPackedParticles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarintPackedParticles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarintPackedParticles.Merge(m, src)
}
func (m *VarintPackedParticles) XXX_Size() int {
	return m.Size()
}
func (m *VarintPackedParticles) XXX_DiscardUnknown() {
	xxx_messageInfo_VarintPackedParticles.DiscardUnknown(m)
}

var xxx_messageInfo_VarintPackedParticles proto.InternalMessageInfo

func (m *VarintPackedParticles) GetParent1() []uint64 {
	if m != nil {
		return m.Parent1
	}
	return nil
}

func (m *VarintPackedParticles) GetParent2() []uint64 {
	if m != nil {
		return m.Parent2
	}
	return nil
}

func (m *VarintPackedParticles) GetChild1() []uint64 {
	if m != nil {
		return m.Child1
	}
	return nil
}

func (m *VarintPackedParticles) GetChild2() []uint64 {
	if m != nil {
		return m.Child2
	}
	return nil
}

func (m *VarintPackedParticles) GetPdg() []int32 {
	if m != nil {
		return m.Pdg
	}
	return nil
}

func (m *VarintPackedParticles) GetX() []int32 {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *VarintPackedParticles) GetY() []int32 {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *VarintPackedParticles) GetZ() []int32 {
	if m != nil {
		return m.Z
	}
	return nil
}

func (m *VarintPackedParticles) GetT() []int32 {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *VarintPackedParticles) GetPx() []int32 {
	if m != nil {
		return m.Px
	}
	return nil
}

func (m *VarintPackedParticles) GetPy() []int32 {
	if m != nil {
		return m.Py
	}
	return nil
}

func (m *VarintPackedParticles) GetPz() []int32 {
	if m != nil {
		return m.Pz
	}
	return nil
}

func (m *VarintPackedParticles) GetMass() []uint32 {
	if m != nil {
		return m.Mass
	}
	return nil
}

func (m *VarintPackedParticles) GetCharge() []int32 {
	if m != nil {
		return m.Charge
	}
	return nil
}

type XYZTD struct {
	X                    float64  `protobuf:"fixed64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float64  `protobuf:"fixed64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float64  `protobuf:"fixed64,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    float64  `protobuf:"fixed64,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTD) Reset()         { *m = XYZTD{} }
func (m *XYZTD) String() string { return proto.CompactTextString(m) }
func (*XYZTD) ProtoMessage()    {}
func (*XYZTD) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{4}
}
func (m *XYZTD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTD.Merge(m, src)
}
func (m *XYZTD) XXX_Size() int {
	return m.Size()
}
func (m *XYZTD) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTD.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTD proto.InternalMessageInfo

func (m *XYZTD) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTD) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTD) GetZ() float64 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTD) GetT() float64 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZTF struct {
	X                    float32  `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float32  `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float32  `protobuf:"fixed32,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    float32  `protobuf:"fixed32,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTF) Reset()         { *m = XYZTF{} }
func (m *XYZTF) String() string { return proto.CompactTextString(m) }
func (*XYZTF) ProtoMessage()    {}
func (*XYZTF) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{5}
}
func (m *XYZTF) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTF) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTF.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTF) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTF.Merge(m, src)
}
func (m *XYZTF) XXX_Size() int {
	return m.Size()
}
func (m *XYZTF) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTF.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTF proto.InternalMessageInfo

func (m *XYZTF) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTF) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTF) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTF) GetT() float32 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZTL struct {
	X                    int64    `protobuf:"zigzag64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int64    `protobuf:"zigzag64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int64    `protobuf:"zigzag64,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    int64    `protobuf:"zigzag64,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTL) Reset()         { *m = XYZTL{} }
func (m *XYZTL) String() string { return proto.CompactTextString(m) }
func (*XYZTL) ProtoMessage()    {}
func (*XYZTL) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{6}
}
func (m *XYZTL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTL.Merge(m, src)
}
func (m *XYZTL) XXX_Size() int {
	return m.Size()
}
func (m *XYZTL) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTL.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTL proto.InternalMessageInfo

func (m *XYZTL) GetX() int64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTL) GetY() int64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTL) GetZ() int64 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTL) GetT() int64 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZTI struct {
	X                    int32    `protobuf:"zigzag32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"zigzag32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int32    `protobuf:"zigzag32,3,opt,name=z,proto3" json:"z,omitempty"`
	T                    int32    `protobuf:"zigzag32,4,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZTI) Reset()         { *m = XYZTI{} }
func (m *XYZTI) String() string { return proto.CompactTextString(m) }
func (*XYZTI) ProtoMessage()    {}
func (*XYZTI) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{7}
}
func (m *XYZTI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZTI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZTI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZTI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZTI.Merge(m, src)
}
func (m *XYZTI) XXX_Size() int {
	return m.Size()
}
func (m *XYZTI) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZTI.DiscardUnknown(m)
}

var xxx_messageInfo_XYZTI proto.InternalMessageInfo

func (m *XYZTI) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZTI) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZTI) GetZ() int32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *XYZTI) GetT() int32 {
	if m != nil {
		return m.T
	}
	return 0
}

type XYZD struct {
	X                    float64  `protobuf:"fixed64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float64  `protobuf:"fixed64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float64  `protobuf:"fixed64,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZD) Reset()         { *m = XYZD{} }
func (m *XYZD) String() string { return proto.CompactTextString(m) }
func (*XYZD) ProtoMessage()    {}
func (*XYZD) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{8}
}
func (m *XYZD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZD.Merge(m, src)
}
func (m *XYZD) XXX_Size() int {
	return m.Size()
}
func (m *XYZD) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZD.DiscardUnknown(m)
}

var xxx_messageInfo_XYZD proto.InternalMessageInfo

func (m *XYZD) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZD) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZD) GetZ() float64 {
	if m != nil {
		return m.Z
	}
	return 0
}

type XYZF struct {
	X                    float32  `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float32  `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float32  `protobuf:"fixed32,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZF) Reset()         { *m = XYZF{} }
func (m *XYZF) String() string { return proto.CompactTextString(m) }
func (*XYZF) ProtoMessage()    {}
func (*XYZF) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{9}
}
func (m *XYZF) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZF) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZF.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZF) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZF.Merge(m, src)
}
func (m *XYZF) XXX_Size() int {
	return m.Size()
}
func (m *XYZF) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZF.DiscardUnknown(m)
}

var xxx_messageInfo_XYZF proto.InternalMessageInfo

func (m *XYZF) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZF) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZF) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type XYZL struct {
	X                    int64    `protobuf:"zigzag64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int64    `protobuf:"zigzag64,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int64    `protobuf:"zigzag64,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZL) Reset()         { *m = XYZL{} }
func (m *XYZL) String() string { return proto.CompactTextString(m) }
func (*XYZL) ProtoMessage()    {}
func (*XYZL) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{10}
}
func (m *XYZL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZL.Merge(m, src)
}
func (m *XYZL) XXX_Size() int {
	return m.Size()
}
func (m *XYZL) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZL.DiscardUnknown(m)
}

var xxx_messageInfo_XYZL proto.InternalMessageInfo

func (m *XYZL) GetX() int64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZL) GetY() int64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZL) GetZ() int64 {
	if m != nil {
		return m.Z
	}
	return 0
}

type XYZI struct {
	X                    int32    `protobuf:"zigzag32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"zigzag32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    int32    `protobuf:"zigzag32,3,opt,name=z,proto3" json:"z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XYZI) Reset()         { *m = XYZI{} }
func (m *XYZI) String() string { return proto.CompactTextString(m) }
func (*XYZI) ProtoMessage()    {}
func (*XYZI) Descriptor() ([]byte, []int) {
	return fileDescriptor_9169c35b9136f42e, []int{11}
}
func (m *XYZI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XYZI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XYZI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XYZI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XYZI.Merge(m, src)
}
func (m *XYZI) XXX_Size() int {
	return m.Size()
}
func (m *XYZI) XXX_DiscardUnknown() {
	xxx_messageInfo_XYZI.DiscardUnknown(m)
}

var xxx_messageInfo_XYZI proto.InternalMessageInfo

func (m *XYZI) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *XYZI) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *XYZI) GetZ() int32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func init() {
	proto.RegisterType((*Particle)(nil), "proio.model.example.Particle")
	proto.RegisterType((*VarintParticle)(nil), "proio.model.example.VarintParticle")
	proto.RegisterType((*PackedParticles)(nil), "proio.model.example.PackedParticles")
	proto.RegisterType((*VarintPackedParticles)(nil), "proio.model.example.VarintPackedParticles")
	proto.RegisterType((*XYZTD)(nil), "proio.model.example.XYZTD")
	proto.RegisterType((*XYZTF)(nil), "proio.model.example.XYZTF")
	proto.RegisterType((*XYZTL)(nil), "proio.model.example.XYZTL")
	proto.RegisterType((*XYZTI)(nil), "proio.model.example.XYZTI")
	proto.RegisterType((*XYZD)(nil), "proio.model.example.XYZD")
	proto.RegisterType((*XYZF)(nil), "proio.model.example.XYZF")
	proto.RegisterType((*XYZL)(nil), "proio.model.example.XYZL")
	proto.RegisterType((*XYZI)(nil), "proio.model.example.XYZI")
}

func init() { proto.RegisterFile("proio/model/example/example.proto", fileDescriptor_9169c35b9136f42e) }

var fileDescriptor_9169c35b9136f42e = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x95, 0x4f, 0x8b, 0xd3, 0x40,
	0x18, 0xc6, 0x9d, 0x49, 0xda, 0xac, 0x6f, 0xb7, 0xd5, 0x19, 0xff, 0x30, 0x7a, 0x28, 0xb1, 0x17,
	0x73, 0x4a, 0xdd, 0xf8, 0x01, 0x84, 0x45, 0x0b, 0x05, 0x0f, 0x4b, 0x10, 0xd9, 0xed, 0x2d, 0x36,
	0xc3, 0x6e, 0x30, 0xdd, 0x0c, 0x69, 0x90, 0xb4, 0x9f, 0x44, 0xf0, 0xe4, 0xb7, 0xf1, 0x28, 0x78,
	0xf2, 0x26, 0xf5, 0x8b, 0x48, 0xe6, 0x4f, 0xdb, 0xa9, 0xca, 0x92, 0x93, 0x9e, 0x3a, 0xbf, 0x77,
	0xde, 0x79, 0xfa, 0x3e, 0x4f, 0xc2, 0x04, 0x9e, 0x88, 0xb2, 0xc8, 0x8a, 0xf1, 0xa2, 0x48, 0x79,
	0x3e, 0xe6, 0x75, 0xb2, 0x10, 0x39, 0x37, 0xbf, 0xa1, 0x28, 0x8b, 0xaa, 0xa0, 0xf7, 0x64, 0x4b,
	0x28, 0x5b, 0x42, 0xbd, 0x35, 0xfa, 0x86, 0xe0, 0xe8, 0x2c, 0x29, 0xab, 0x6c, 0x9e, 0x73, 0xfa,
	0x10, 0xba, 0x22, 0x29, 0xf9, 0x75, 0xc5, 0x90, 0xef, 0x04, 0x6e, 0xac, 0x89, 0xde, 0x87, 0xce,
	0xfc, 0x2a, 0xcb, 0x53, 0x86, 0x65, 0x59, 0x01, 0xbd, 0x0b, 0x8e, 0x48, 0x2f, 0x99, 0xe3, 0xa3,
	0x80, 0xc4, 0xcd, 0x92, 0x46, 0xd0, 0xfd, 0xc0, 0xcb, 0x8a, 0xd7, 0xcc, 0xf5, 0x51, 0xd0, 0x8b,
	0x1e, 0x87, 0x7f, 0xf8, 0xcb, 0xf0, 0xfc, 0x62, 0xf6, 0x66, 0x12, 0xeb, 0x4e, 0xfa, 0x14, 0x90,
	0x60, 0x1d, 0xd9, 0xfe, 0xe8, 0x6f, 0xed, 0x93, 0x18, 0x09, 0x4a, 0xc1, 0x5d, 0x24, 0xcb, 0x25,
	0xeb, 0xfa, 0x28, 0xc0, 0xb1, 0x5c, 0x37, 0x03, 0xcf, 0xaf, 0x92, 0xf2, 0x92, 0x33, 0x4f, 0x4e,
	0xa1, 0x69, 0xf4, 0x1d, 0xc1, 0xe0, 0x6d, 0x52, 0x66, 0xd7, 0xd5, 0x3f, 0xf0, 0x36, 0x6d, 0xe5,
	0x6d, 0x7a, 0xe8, 0xad, 0x7f, 0x83, 0xb7, 0x4f, 0x18, 0xee, 0x9c, 0x25, 0xf3, 0xf7, 0x3c, 0x35,
	0xde, 0x96, 0x94, 0x81, 0xa7, 0xec, 0x9c, 0x68, 0x77, 0x06, 0x77, 0x3b, 0x91, 0x36, 0x68, 0x50,
	0xe9, 0x67, 0x79, 0x7a, 0xc2, 0x1c, 0x15, 0x88, 0xa2, 0x6d, 0x3d, 0x62, 0xee, 0x5e, 0x3d, 0x32,
	0x91, 0x74, 0x7c, 0xc7, 0x44, 0x72, 0x0c, 0xa8, 0x66, 0x5d, 0xdf, 0x09, 0x70, 0x8c, 0xea, 0x86,
	0x56, 0xcc, 0x53, 0xb4, 0x6a, 0x68, 0xcd, 0x8e, 0x14, 0xad, 0x1b, 0xaa, 0xd8, 0x6d, 0x45, 0x15,
	0x1d, 0x00, 0x16, 0x35, 0x03, 0x89, 0x58, 0xd4, 0x92, 0x57, 0xac, 0xa7, 0x79, 0x25, 0x79, 0xcd,
	0x8e, 0x35, 0xaf, 0xb7, 0xe9, 0xf4, 0x65, 0xe5, 0x30, 0x9d, 0x81, 0x1c, 0xc8, 0xa4, 0xf3, 0x19,
	0xc3, 0x03, 0xf3, 0xe4, 0xff, 0xab, 0x8c, 0x88, 0x95, 0x11, 0xb1, 0x32, 0x22, 0x56, 0x46, 0xc4,
	0xce, 0x88, 0x1c, 0x64, 0x44, 0x0e, 0x32, 0x22, 0xbf, 0x65, 0xd4, 0xbf, 0x21, 0xa3, 0x17, 0xd0,
	0x69, 0xde, 0xd3, 0x97, 0x6a, 0x38, 0xe4, 0xa3, 0x00, 0x6d, 0x87, 0xc3, 0x8a, 0xf4, 0x70, 0x8e,
	0x22, 0x3d, 0x9c, 0xab, 0xa8, 0x32, 0x02, 0x93, 0x9d, 0x00, 0xb6, 0x04, 0xb0, 0x25, 0x80, 0x2d,
	0x01, 0xbc, 0x27, 0xf0, 0x7a, 0x27, 0x40, 0x2d, 0x01, 0x6a, 0x09, 0x50, 0x4b, 0x80, 0xee, 0x09,
	0x4c, 0x77, 0x02, 0xc4, 0x12, 0x20, 0x96, 0x00, 0xb1, 0x04, 0x9a, 0x7c, 0x47, 0xcf, 0xc0, 0x3d,
	0xbf, 0x98, 0xb5, 0x88, 0x40, 0x9f, 0x68, 0xe1, 0x59, 0x9f, 0x68, 0x61, 0x52, 0x9f, 0x68, 0xe1,
	0xea, 0x74, 0xfc, 0x65, 0x33, 0x44, 0x5f, 0x37, 0x43, 0xf4, 0x63, 0x33, 0x44, 0x1f, 0x7f, 0x0e,
	0x6f, 0x41, 0x6f, 0xef, 0xa2, 0x39, 0xf5, 0x5e, 0xa9, 0x9b, 0x66, 0xe6, 0xe9, 0x2b, 0xe7, 0x5d,
	0x57, 0x7e, 0x0c, 0x9e, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xd1, 0xc3, 0x51, 0x45, 0x31, 0x06,
	0x00, 0x00,
}

func (m *Particle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Particle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parent) > 0 {
		dAtA2 := make([]byte, len(m.Parent)*10)
		var j1 int
		for _, num := range m.Parent {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintExample(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Child) > 0 {
		dAtA4 := make([]byte, len(m.Child)*10)
		var j3 int
		for _, num := range m.Child {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintExample(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.Pdg != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Pdg)<<1)^uint32((m.Pdg>>31))))
	}
	if m.Vertex != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExample(dAtA, i, uint64(m.Vertex.Size()))
		n5, err := m.Vertex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.P != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExample(dAtA, i, uint64(m.P.Size()))
		n6, err := m.P.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Mass != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Mass))))
		i += 4
	}
	if m.Charge != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Charge)<<1)^uint32((m.Charge>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VarintParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarintParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parent) > 0 {
		dAtA8 := make([]byte, len(m.Parent)*10)
		var j7 int
		for _, num := range m.Parent {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintExample(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Child) > 0 {
		dAtA10 := make([]byte, len(m.Child)*10)
		var j9 int
		for _, num := range m.Child {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintExample(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.Pdg != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Pdg)<<1)^uint32((m.Pdg>>31))))
	}
	if m.Vertex != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExample(dAtA, i, uint64(m.Vertex.Size()))
		n11, err := m.Vertex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.P != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExample(dAtA, i, uint64(m.P.Size()))
		n12, err := m.P.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Mass != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintExample(dAtA, i, uint64(m.Mass))
	}
	if m.Charge != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Charge)<<1)^uint32((m.Charge>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PackedParticles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackedParticles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parent1) > 0 {
		dAtA14 := make([]byte, len(m.Parent1)*10)
		var j13 int
		for _, num := range m.Parent1 {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintExample(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.Parent2) > 0 {
		dAtA16 := make([]byte, len(m.Parent2)*10)
		var j15 int
		for _, num := range m.Parent2 {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintExample(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if len(m.Child1) > 0 {
		dAtA18 := make([]byte, len(m.Child1)*10)
		var j17 int
		for _, num := range m.Child1 {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if len(m.Child2) > 0 {
		dAtA20 := make([]byte, len(m.Child2)*10)
		var j19 int
		for _, num := range m.Child2 {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintExample(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if len(m.Pdg) > 0 {
		dAtA21 := make([]byte, len(m.Pdg)*5)
		var j22 int
		for _, num := range m.Pdg {
			x23 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x23 >= 1<<7 {
				dAtA21[j22] = uint8(uint64(x23)&0x7f | 0x80)
				j22++
				x23 >>= 7
			}
			dAtA21[j22] = uint8(x23)
			j22++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA21[:j22])
	}
	if len(m.X) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.X)*4))
		for _, num := range m.X {
			f24 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f24))
			i += 4
		}
	}
	if len(m.Y) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.Y)*4))
		for _, num := range m.Y {
			f25 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f25))
			i += 4
		}
	}
	if len(m.Z) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.Z)*4))
		for _, num := range m.Z {
			f26 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f26))
			i += 4
		}
	}
	if len(m.T) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.T)*4))
		for _, num := range m.T {
			f27 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f27))
			i += 4
		}
	}
	if len(m.Px) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.Px)*4))
		for _, num := range m.Px {
			f28 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f28))
			i += 4
		}
	}
	if len(m.Py) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.Py)*4))
		for _, num := range m.Py {
			f29 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f29))
			i += 4
		}
	}
	if len(m.Pz) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.Pz)*4))
		for _, num := range m.Pz {
			f30 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f30))
			i += 4
		}
	}
	if len(m.Mass) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintExample(dAtA, i, uint64(len(m.Mass)*4))
		for _, num := range m.Mass {
			f31 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f31))
			i += 4
		}
	}
	if len(m.Charge) > 0 {
		dAtA32 := make([]byte, len(m.Charge)*5)
		var j33 int
		for _, num := range m.Charge {
			x34 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x34 >= 1<<7 {
				dAtA32[j33] = uint8(uint64(x34)&0x7f | 0x80)
				j33++
				x34 >>= 7
			}
			dAtA32[j33] = uint8(x34)
			j33++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintExample(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA32[:j33])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VarintPackedParticles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarintPackedParticles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parent1) > 0 {
		dAtA36 := make([]byte, len(m.Parent1)*10)
		var j35 int
		for _, num := range m.Parent1 {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintExample(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	if len(m.Parent2) > 0 {
		dAtA38 := make([]byte, len(m.Parent2)*10)
		var j37 int
		for _, num := range m.Parent2 {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintExample(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	if len(m.Child1) > 0 {
		dAtA40 := make([]byte, len(m.Child1)*10)
		var j39 int
		for _, num := range m.Child1 {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	if len(m.Child2) > 0 {
		dAtA42 := make([]byte, len(m.Child2)*10)
		var j41 int
		for _, num := range m.Child2 {
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintExample(dAtA, i, uint64(j41))
		i += copy(dAtA[i:], dAtA42[:j41])
	}
	if len(m.Pdg) > 0 {
		dAtA43 := make([]byte, len(m.Pdg)*5)
		var j44 int
		for _, num := range m.Pdg {
			x45 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x45 >= 1<<7 {
				dAtA43[j44] = uint8(uint64(x45)&0x7f | 0x80)
				j44++
				x45 >>= 7
			}
			dAtA43[j44] = uint8(x45)
			j44++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j44))
		i += copy(dAtA[i:], dAtA43[:j44])
	}
	if len(m.X) > 0 {
		dAtA46 := make([]byte, len(m.X)*5)
		var j47 int
		for _, num := range m.X {
			x48 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x48 >= 1<<7 {
				dAtA46[j47] = uint8(uint64(x48)&0x7f | 0x80)
				j47++
				x48 >>= 7
			}
			dAtA46[j47] = uint8(x48)
			j47++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintExample(dAtA, i, uint64(j47))
		i += copy(dAtA[i:], dAtA46[:j47])
	}
	if len(m.Y) > 0 {
		dAtA49 := make([]byte, len(m.Y)*5)
		var j50 int
		for _, num := range m.Y {
			x51 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x51 >= 1<<7 {
				dAtA49[j50] = uint8(uint64(x51)&0x7f | 0x80)
				j50++
				x51 >>= 7
			}
			dAtA49[j50] = uint8(x51)
			j50++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j50))
		i += copy(dAtA[i:], dAtA49[:j50])
	}
	if len(m.Z) > 0 {
		dAtA52 := make([]byte, len(m.Z)*5)
		var j53 int
		for _, num := range m.Z {
			x54 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x54 >= 1<<7 {
				dAtA52[j53] = uint8(uint64(x54)&0x7f | 0x80)
				j53++
				x54 >>= 7
			}
			dAtA52[j53] = uint8(x54)
			j53++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintExample(dAtA, i, uint64(j53))
		i += copy(dAtA[i:], dAtA52[:j53])
	}
	if len(m.T) > 0 {
		dAtA55 := make([]byte, len(m.T)*5)
		var j56 int
		for _, num := range m.T {
			x57 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x57 >= 1<<7 {
				dAtA55[j56] = uint8(uint64(x57)&0x7f | 0x80)
				j56++
				x57 >>= 7
			}
			dAtA55[j56] = uint8(x57)
			j56++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j56))
		i += copy(dAtA[i:], dAtA55[:j56])
	}
	if len(m.Px) > 0 {
		dAtA58 := make([]byte, len(m.Px)*5)
		var j59 int
		for _, num := range m.Px {
			x60 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x60 >= 1<<7 {
				dAtA58[j59] = uint8(uint64(x60)&0x7f | 0x80)
				j59++
				x60 >>= 7
			}
			dAtA58[j59] = uint8(x60)
			j59++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintExample(dAtA, i, uint64(j59))
		i += copy(dAtA[i:], dAtA58[:j59])
	}
	if len(m.Py) > 0 {
		dAtA61 := make([]byte, len(m.Py)*5)
		var j62 int
		for _, num := range m.Py {
			x63 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x63 >= 1<<7 {
				dAtA61[j62] = uint8(uint64(x63)&0x7f | 0x80)
				j62++
				x63 >>= 7
			}
			dAtA61[j62] = uint8(x63)
			j62++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j62))
		i += copy(dAtA[i:], dAtA61[:j62])
	}
	if len(m.Pz) > 0 {
		dAtA64 := make([]byte, len(m.Pz)*5)
		var j65 int
		for _, num := range m.Pz {
			x66 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x66 >= 1<<7 {
				dAtA64[j65] = uint8(uint64(x66)&0x7f | 0x80)
				j65++
				x66 >>= 7
			}
			dAtA64[j65] = uint8(x66)
			j65++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintExample(dAtA, i, uint64(j65))
		i += copy(dAtA[i:], dAtA64[:j65])
	}
	if len(m.Mass) > 0 {
		dAtA68 := make([]byte, len(m.Mass)*10)
		var j67 int
		for _, num := range m.Mass {
			for num >= 1<<7 {
				dAtA68[j67] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j67++
			}
			dAtA68[j67] = uint8(num)
			j67++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintExample(dAtA, i, uint64(j67))
		i += copy(dAtA[i:], dAtA68[:j67])
	}
	if len(m.Charge) > 0 {
		dAtA69 := make([]byte, len(m.Charge)*5)
		var j70 int
		for _, num := range m.Charge {
			x71 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x71 >= 1<<7 {
				dAtA69[j70] = uint8(uint64(x71)&0x7f | 0x80)
				j70++
				x71 >>= 7
			}
			dAtA69[j70] = uint8(x71)
			j70++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintExample(dAtA, i, uint64(j70))
		i += copy(dAtA[i:], dAtA69[:j70])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZTD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTD) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X))))
		i += 8
	}
	if m.Y != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Y))))
		i += 8
	}
	if m.Z != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Z))))
		i += 8
	}
	if m.T != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.T))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZTF) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTF) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i += 4
	}
	if m.Y != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i += 4
	}
	if m.Z != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
		i += 4
	}
	if m.T != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.T))))
		i += 4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZTL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTL) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.X)<<1)^uint64((m.X>>63))))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Y)<<1)^uint64((m.Y>>63))))
	}
	if m.Z != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Z)<<1)^uint64((m.Z>>63))))
	}
	if m.T != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.T)<<1)^uint64((m.T>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZTI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZTI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.X)<<1)^uint32((m.X>>31))))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Y)<<1)^uint32((m.Y>>31))))
	}
	if m.Z != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Z)<<1)^uint32((m.Z>>31))))
	}
	if m.T != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.T)<<1)^uint32((m.T>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZD) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X))))
		i += 8
	}
	if m.Y != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Y))))
		i += 8
	}
	if m.Z != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Z))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZF) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZF) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i += 4
	}
	if m.Y != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i += 4
	}
	if m.Z != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
		i += 4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZL) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.X)<<1)^uint64((m.X>>63))))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Y)<<1)^uint64((m.Y>>63))))
	}
	if m.Z != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint64(m.Z)<<1)^uint64((m.Z>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *XYZI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XYZI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.X)<<1)^uint32((m.X>>31))))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Y)<<1)^uint32((m.Y>>31))))
	}
	if m.Z != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExample(dAtA, i, uint64((uint32(m.Z)<<1)^uint32((m.Z>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintExample(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Particle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent) > 0 {
		l = 0
		for _, e := range m.Parent {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child) > 0 {
		l = 0
		for _, e := range m.Child {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.Pdg != 0 {
		n += 1 + sozExample(uint64(m.Pdg))
	}
	if m.Vertex != nil {
		l = m.Vertex.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.Mass != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 1 + sozExample(uint64(m.Charge))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarintParticle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent) > 0 {
		l = 0
		for _, e := range m.Parent {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child) > 0 {
		l = 0
		for _, e := range m.Child {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.Pdg != 0 {
		n += 1 + sozExample(uint64(m.Pdg))
	}
	if m.Vertex != nil {
		l = m.Vertex.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovExample(uint64(l))
	}
	if m.Mass != 0 {
		n += 1 + sovExample(uint64(m.Mass))
	}
	if m.Charge != 0 {
		n += 1 + sozExample(uint64(m.Charge))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PackedParticles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent1) > 0 {
		l = 0
		for _, e := range m.Parent1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Parent2) > 0 {
		l = 0
		for _, e := range m.Parent2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child1) > 0 {
		l = 0
		for _, e := range m.Child1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child2) > 0 {
		l = 0
		for _, e := range m.Child2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Pdg) > 0 {
		l = 0
		for _, e := range m.Pdg {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.X) > 0 {
		n += 1 + sovExample(uint64(len(m.X)*4)) + len(m.X)*4
	}
	if len(m.Y) > 0 {
		n += 1 + sovExample(uint64(len(m.Y)*4)) + len(m.Y)*4
	}
	if len(m.Z) > 0 {
		n += 1 + sovExample(uint64(len(m.Z)*4)) + len(m.Z)*4
	}
	if len(m.T) > 0 {
		n += 1 + sovExample(uint64(len(m.T)*4)) + len(m.T)*4
	}
	if len(m.Px) > 0 {
		n += 1 + sovExample(uint64(len(m.Px)*4)) + len(m.Px)*4
	}
	if len(m.Py) > 0 {
		n += 1 + sovExample(uint64(len(m.Py)*4)) + len(m.Py)*4
	}
	if len(m.Pz) > 0 {
		n += 1 + sovExample(uint64(len(m.Pz)*4)) + len(m.Pz)*4
	}
	if len(m.Mass) > 0 {
		n += 1 + sovExample(uint64(len(m.Mass)*4)) + len(m.Mass)*4
	}
	if len(m.Charge) > 0 {
		l = 0
		for _, e := range m.Charge {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarintPackedParticles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parent1) > 0 {
		l = 0
		for _, e := range m.Parent1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Parent2) > 0 {
		l = 0
		for _, e := range m.Parent2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child1) > 0 {
		l = 0
		for _, e := range m.Child1 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Child2) > 0 {
		l = 0
		for _, e := range m.Child2 {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Pdg) > 0 {
		l = 0
		for _, e := range m.Pdg {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.X) > 0 {
		l = 0
		for _, e := range m.X {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Y) > 0 {
		l = 0
		for _, e := range m.Y {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Z) > 0 {
		l = 0
		for _, e := range m.Z {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.T) > 0 {
		l = 0
		for _, e := range m.T {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Px) > 0 {
		l = 0
		for _, e := range m.Px {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Py) > 0 {
		l = 0
		for _, e := range m.Py {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Pz) > 0 {
		l = 0
		for _, e := range m.Pz {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Mass) > 0 {
		l = 0
		for _, e := range m.Mass {
			l += sovExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if len(m.Charge) > 0 {
		l = 0
		for _, e := range m.Charge {
			l += sozExample(uint64(e))
		}
		n += 1 + sovExample(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	if m.Z != 0 {
		n += 9
	}
	if m.T != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTF) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	if m.T != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.T != 0 {
		n += 1 + sozExample(uint64(m.T))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZTI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.T != 0 {
		n += 1 + sozExample(uint64(m.T))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	if m.Z != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZF) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XYZI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sozExample(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sozExample(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sozExample(uint64(m.Z))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExample(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExample(x uint64) (n int) {
	return sovExample(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Particle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Particle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Particle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent = append(m.Parent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent) == 0 {
					m.Parent = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent = append(m.Parent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child = append(m.Child, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child) == 0 {
					m.Child = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child = append(m.Child, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Pdg = v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vertex == nil {
				m.Vertex = &XYZTF{}
			}
			if err := m.Vertex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &XYZF{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Mass = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Charge = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarintParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarintParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarintParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent = append(m.Parent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent) == 0 {
					m.Parent = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent = append(m.Parent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child = append(m.Child, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child) == 0 {
					m.Child = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child = append(m.Child, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Pdg = v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vertex == nil {
				m.Vertex = &XYZTI{}
			}
			if err := m.Vertex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExample
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &XYZI{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			m.Mass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mass |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Charge = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackedParticles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackedParticles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackedParticles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent1 = append(m.Parent1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent1) == 0 {
					m.Parent1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent1 = append(m.Parent1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent1", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent2 = append(m.Parent2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent2) == 0 {
					m.Parent2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent2 = append(m.Parent2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child1 = append(m.Child1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child1) == 0 {
					m.Child1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child1 = append(m.Child1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child1", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child2 = append(m.Child2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child2) == 0 {
					m.Child2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child2 = append(m.Child2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child2", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Pdg = append(m.Pdg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Pdg) == 0 {
					m.Pdg = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Pdg = append(m.Pdg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.X = append(m.X, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.X) == 0 {
					m.X = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.X = append(m.X, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Y = append(m.Y, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Y) == 0 {
					m.Y = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Y = append(m.Y, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Z = append(m.Z, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Z) == 0 {
					m.Z = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Z = append(m.Z, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.T = append(m.T, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.T) == 0 {
					m.T = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.T = append(m.T, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
		case 10:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Px = append(m.Px, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Px) == 0 {
					m.Px = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Px = append(m.Px, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Px", wireType)
			}
		case 11:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Py = append(m.Py, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Py) == 0 {
					m.Py = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Py = append(m.Py, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Py", wireType)
			}
		case 12:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pz = append(m.Pz, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Pz) == 0 {
					m.Pz = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pz = append(m.Pz, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pz", wireType)
			}
		case 13:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Mass = append(m.Mass, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Mass) == 0 {
					m.Mass = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Mass = append(m.Mass, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Charge = append(m.Charge, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Charge) == 0 {
					m.Charge = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Charge = append(m.Charge, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarintPackedParticles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarintPackedParticles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarintPackedParticles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent1 = append(m.Parent1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent1) == 0 {
					m.Parent1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent1 = append(m.Parent1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent1", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parent2 = append(m.Parent2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parent2) == 0 {
					m.Parent2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parent2 = append(m.Parent2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child1 = append(m.Child1, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child1) == 0 {
					m.Child1 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child1 = append(m.Child1, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child1", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Child2 = append(m.Child2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Child2) == 0 {
					m.Child2 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Child2 = append(m.Child2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Child2", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Pdg = append(m.Pdg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Pdg) == 0 {
					m.Pdg = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Pdg = append(m.Pdg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdg", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.X = append(m.X, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.X) == 0 {
					m.X = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.X = append(m.X, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Y = append(m.Y, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Y) == 0 {
					m.Y = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Y = append(m.Y, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Z = append(m.Z, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Z) == 0 {
					m.Z = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Z = append(m.Z, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.T = append(m.T, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.T) == 0 {
					m.T = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.T = append(m.T, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Px = append(m.Px, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Px) == 0 {
					m.Px = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Px = append(m.Px, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Px", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Py = append(m.Py, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Py) == 0 {
					m.Py = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Py = append(m.Py, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Py", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Pz = append(m.Pz, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Pz) == 0 {
					m.Pz = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Pz = append(m.Pz, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pz", wireType)
			}
		case 13:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mass = append(m.Mass, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mass) == 0 {
					m.Mass = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mass = append(m.Mass, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Charge = append(m.Charge, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExample
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExample
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Charge) == 0 {
					m.Charge = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExample
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Charge = append(m.Charge, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Y = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Z = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.T = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTF) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTF: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTF: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.T = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.X = int64(v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Y = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Z = int64(v)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.T = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZTI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZTI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZTI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.X = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Y = v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Z = v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.T = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Y = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Z = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZF) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZF: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZF: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.X = int64(v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Y = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Z = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XYZI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExample
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XYZI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XYZI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.X = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Y = v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExample
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Z = v
		default:
			iNdEx = preIndex
			skippy, err := skipExample(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExample
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExample(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExample
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExample
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExample
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExample
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExample
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExample(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExample = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExample   = fmt.Errorf("proto: integer overflow")
)
